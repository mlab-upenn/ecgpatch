   1               		.file	"accel_data.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 142               	.global	readAccelData
 144               	readAccelData:
 145               		.stabd	46,0,0
   1:accel_data.c  **** #include "accel_data.h"
   2:accel_data.c  **** 
   3:accel_data.c  **** static AccelData accelDataPort;
   4:accel_data.c  **** 
   5:accel_data.c  **** // This function returns the last witen data in the accel data port.
   6:accel_data.c  **** void readAccelData(AccelReading *data)
   7:accel_data.c  **** {
 147               	.LM0:
 148               	.LFBB1:
 149               	/* prologue: frame size=0 */
 150 0000 CF93      		push r28
 151 0002 DF93      		push r29
 152               	/* prologue end (size=2) */
 153 0004 DC01      		movw r26,r24
   8:accel_data.c  ****     int8_t index = accelDataPort.index; // this is necessary so that we dont get a dirty read.
   9:accel_data.c  ****     data->zValue = accelDataPort.data[index].zValue;
 155               	.LM1:
 156 0006 40E0      		ldi r20,lo8(accelDataPort)
 157 0008 50E0      		ldi r21,hi8(accelDataPort)
 158 000a 2091 0000 		lds r18,accelDataPort
 159 000e 3327      		clr r19
 160 0010 27FD      		sbrc r18,7
 161 0012 3095      		com r19
 162 0014 C901      		movw r24,r18
 163 0016 0196      		adiw r24,1
 164 0018 FC01      		movw r30,r24
 165 001a EE0F      		lsl r30
 166 001c FF1F      		rol r31
 167 001e E80F      		add r30,r24
 168 0020 F91F      		adc r31,r25
 169 0022 EE0F      		lsl r30
 170 0024 FF1F      		rol r31
 171 0026 E40F      		add r30,r20
 172 0028 F51F      		adc r31,r21
 173 002a 8081      		ld r24,Z
 174 002c 9181      		ldd r25,Z+1
 175 002e ED01      		movw r28,r26
 176 0030 9D83      		std Y+5,r25
 177 0032 8C83      		std Y+4,r24
  10:accel_data.c  ****     data->yValue = accelDataPort.data[index].yValue;
 179               	.LM2:
 180 0034 F901      		movw r30,r18
 181 0036 EE0F      		lsl r30
 182 0038 FF1F      		rol r31
 183 003a E20F      		add r30,r18
 184 003c F31F      		adc r31,r19
 185 003e EE0F      		lsl r30
 186 0040 FF1F      		rol r31
 187 0042 E40F      		add r30,r20
 188 0044 F51F      		adc r31,r21
 189 0046 8481      		ldd r24,Z+4
 190 0048 9581      		ldd r25,Z+5
 191 004a 9B83      		std Y+3,r25
 192 004c 8A83      		std Y+2,r24
  11:accel_data.c  ****     data->xValue = accelDataPort.data[index].xValue;
 194               	.LM3:
 195 004e 8281      		ldd r24,Z+2
 196 0050 9381      		ldd r25,Z+3
 197 0052 8D93      		st X+,r24
 198 0054 9C93      		st X,r25
 199               	/* epilogue: frame size=0 */
 200 0056 DF91      		pop r29
 201 0058 CF91      		pop r28
 202 005a 0895      		ret
 203               	/* epilogue end (size=3) */
 204               	/* function readAccelData size 46 (41) */
 206               	.Lscope1:
 208               		.stabd	78,0,0
 211               	.global	writeAccelData
 213               	writeAccelData:
 214               		.stabd	46,0,0
  12:accel_data.c  **** }
  13:accel_data.c  **** 
  14:accel_data.c  **** // ths functio write the the data in the last w
  15:accel_data.c  **** void writeAccelData(AccelReading *data)
  16:accel_data.c  **** {
 216               	.LM4:
 217               	.LFBB2:
 218               	/* prologue: frame size=0 */
 219 005c CF93      		push r28
 220 005e DF93      		push r29
 221               	/* prologue end (size=2) */
 222 0060 DC01      		movw r26,r24
  17:accel_data.c  ****     // you should write on the index that is not being currently read.
  18:accel_data.c  ****     int8_t index = accelDataPort.index ^ 1;
 224               	.LM5:
 225 0062 60E0      		ldi r22,lo8(accelDataPort)
 226 0064 70E0      		ldi r23,hi8(accelDataPort)
 227 0066 4091 0000 		lds r20,accelDataPort
 228 006a 5091 0000 		lds r21,(accelDataPort)+1
  19:accel_data.c  ****     accelDataPort.data[index].zValue = data->zValue;
 230               	.LM6:
 231 006e 81E0      		ldi r24,lo8(1)
 232 0070 8427      		eor r24,r20
 233 0072 9927      		clr r25
 234 0074 87FD      		sbrc r24,7
 235 0076 9095      		com r25
 236 0078 9C01      		movw r18,r24
 237 007a 2F5F      		subi r18,lo8(-(1))
 238 007c 3F4F      		sbci r19,hi8(-(1))
 239 007e F901      		movw r30,r18
 240 0080 EE0F      		lsl r30
 241 0082 FF1F      		rol r31
 242 0084 E20F      		add r30,r18
 243 0086 F31F      		adc r31,r19
 244 0088 EE0F      		lsl r30
 245 008a FF1F      		rol r31
 246 008c E60F      		add r30,r22
 247 008e F71F      		adc r31,r23
 248 0090 ED01      		movw r28,r26
 249 0092 2C81      		ldd r18,Y+4
 250 0094 3D81      		ldd r19,Y+5
 251 0096 3183      		std Z+1,r19
 252 0098 2083      		st Z,r18
  20:accel_data.c  ****     accelDataPort.data[index].yValue = data->yValue;
 254               	.LM7:
 255 009a FC01      		movw r30,r24
 256 009c EE0F      		lsl r30
 257 009e FF1F      		rol r31
 258 00a0 E80F      		add r30,r24
 259 00a2 F91F      		adc r31,r25
 260 00a4 EE0F      		lsl r30
 261 00a6 FF1F      		rol r31
 262 00a8 E60F      		add r30,r22
 263 00aa F71F      		adc r31,r23
 264 00ac 8A81      		ldd r24,Y+2
 265 00ae 9B81      		ldd r25,Y+3
 266 00b0 9583      		std Z+5,r25
 267 00b2 8483      		std Z+4,r24
  21:accel_data.c  ****     accelDataPort.data[index].xValue = data->xValue;
 269               	.LM8:
 270 00b4 8D91      		ld r24,X+
 271 00b6 9C91      		ld r25,X
 272 00b8 9383      		std Z+3,r25
 273 00ba 8283      		std Z+2,r24
  22:accel_data.c  **** 
  23:accel_data.c  ****     // now toggle the index.
  24:accel_data.c  ****     accelDataPort.index ^= 1;
 275               	.LM9:
 276 00bc 81E0      		ldi r24,lo8(1)
 277 00be 90E0      		ldi r25,hi8(1)
 278 00c0 4827      		eor r20,r24
 279 00c2 5927      		eor r21,r25
 280 00c4 5093 0000 		sts (accelDataPort)+1,r21
 281 00c8 4093 0000 		sts accelDataPort,r20
 282               	/* epilogue: frame size=0 */
 283 00cc DF91      		pop r29
 284 00ce CF91      		pop r28
 285 00d0 0895      		ret
 286               	/* epilogue end (size=3) */
 287               	/* function writeAccelData size 59 (54) */
 289               	.Lscope2:
 291               		.stabd	78,0,0
 292               		.lcomm accelDataPort,14
 293               		.comm _nrk_signal_list,4,1
 294               		.comm nrk_idle_task_stk,128,1
 295               		.comm nrk_kernel_stk_ptr,2,1
 296               		.comm error_task,1,1
 297               		.comm error_num,1,1
 298               		.comm _nrk_prev_timer_val,1,1
 299               		.comm _nrk_time_trigger,1,1
 300               		.comm app_timer0_callback,2,1
 301               		.comm app_timer0_prescale,1,1
 313               	.Letext0:
 314               	/* File "accel_data.c": code  105 = 0x0069 (  95), prologues   4, epilogues   6 */
DEFINED SYMBOLS
                            *ABS*:00000000 accel_data.c
     /tmp/ccqCaZ7w.s:2      *ABS*:0000003f __SREG__
     /tmp/ccqCaZ7w.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccqCaZ7w.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccqCaZ7w.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccqCaZ7w.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccqCaZ7w.s:144    .text:00000000 readAccelData
                             .bss:00000000 accelDataPort
     /tmp/ccqCaZ7w.s:213    .text:0000005c writeAccelData
                            *COM*:00000004 _nrk_signal_list
                            *COM*:00000080 nrk_idle_task_stk
                            *COM*:00000002 nrk_kernel_stk_ptr
                            *COM*:00000001 error_task
                            *COM*:00000001 error_num
                            *COM*:00000001 _nrk_prev_timer_val
                            *COM*:00000001 _nrk_time_trigger
                            *COM*:00000002 app_timer0_callback
                            *COM*:00000001 app_timer0_prescale

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
